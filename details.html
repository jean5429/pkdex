<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokémon Details</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }

        .card-custom {
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
        }
        .card-custom:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        .typestyle {
            font-weight: bold;
            border-radius: 9999px;
            padding: 4px 12px;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            margin-bottom: 8px;
            text-transform: capitalize;
            white-space: nowrap;
        }

        .stat-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
            width: 100%;
        }

        .stat-name {
            flex-basis: 80px;
            text-align: right;
            font-weight: bold;
            color: #4b5563;
        }

        .bar-container {
            flex-grow: 1;
            height: 16px;
            background-color: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }

        .bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 9999px;
            transition: width 0.8s ease-out, background-color 0.8s ease-out;
        }

        .stat-value {
            flex-basis: 30px;
            text-align: left;
            font-weight: bold;
            color: #4b5563;
        }

        .red-bar { background-color: #ef4444; }
        .yellow-bar { background-color: #f59e0b; }
        .green-bar { background-color: #22c55e; }

        .moves-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 15px;
            font-size: 0.95rem;
            border-radius: 8px;
            overflow: hidden;
        }

        .moves-table th,
        .moves-table td {
            border: none;
            padding: 12px 15px;
            text-align: left;
        }

        .moves-table th {
            background-color: #e0e7ff;
            font-weight: 700;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .moves-table th:not(:last-child),
        .moves-table td:not(:last-child) {
            border-right: 1px solid #e5e7eb;
        }
        .moves-table tr:not(:last-child) th,
        .moves-table tr:not(:last-child) td {
            border-bottom: 1px solid #e5e7eb;
        }

        .moves-table tbody tr:nth-child(even) {
            background-color: #f9fafb;
        }

        .moves-table tbody tr:hover {
            background-color: #eef2f6;
        }

        .filter-btn {
            @apply px-5 py-2.5 rounded-lg border border-gray-300 bg-gray-50 text-gray-700 font-semibold cursor-pointer transition-all duration-200 ease-in-out;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .filter-btn:hover {
            @apply bg-gray-100 border-gray-400;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .filter-btn.active {
            @apply bg-blue-600 text-white border-blue-700;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .moves-table tbody tr[style*="display: table-row"] {
            display: table-row !important;
        }

        .evolution-tree-card {
        }

        .evolution-tree-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 100%;
        }

        .evolution-pokemon-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 5px;
        }

        .evolution-pokemon-item img {
            width: 80px;
            height: 80px;
            object-fit: contain;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
            image-rendering: pixelated;
        }
        .evolution-pokemon-item img:hover {
            transform: scale(1.1);
        }
        .evolution-pokemon-item p {
            margin-top: 5px;
            font-size: 0.9rem;
            color: #4b5563;
            text-transform: capitalize;
            line-height: 1.2;
        }
        .evolution-pokemon-item p.selected {
            font-weight: bold;
            color: #10b981;
        }

        .evolution-conditions {
            font-size: 0.75rem;
            color: #6b7280;
            line-height: 1.2;
            max-width: 120px;
        }

        .evolution-branch-connector {
            margin: 10px 0;
        }

        .evolution-branches {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
        }

        .evolution-branch-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .main-grid {
            display: grid;
            gap: 24px;
            grid-template-columns: 1fr;
        }

        @media (min-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (min-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr 1fr 1fr;
            }
        }

        .pokemon-info-card {
            grid-column: span 1;
        }
        .stats-card {
            grid-column: span 1;
        }
        .evolution-tree-card {
            grid-column: span 1;
        }
        .moves-card {
            grid-column: span 1;
            @media (min-width: 768px) {
                grid-column: span 2;
            }
            @media (min-width: 1024px) {
                grid-column: span 2;
            }
        }
        .locations-card {
            grid-column: span 1;
            @media (min-width: 1024px) {
                grid-column: span 1;
            }
        }
        .location-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .location-item {
            background-color: #f0f4f8;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: #374151;
        }
        .location-item:last-child {
            margin-bottom: 0;
        }
        .location-item .version-tag {
            background-color: #bfdbfe;
            color: #1e40af;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 0.75rem;
            white-space: nowrap;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center py-8 px-4">

    <div class="container mx-auto max-w-6xl">
        <h1 id="pokemonNameHeader" class="text-3xl sm:text-4xl font-extrabold text-gray-800 text-center mb-8 capitalize">
            Loading Pokémon...
        </h1>

        <div class="flex flex-col items-center gap-4 mb-8">
            <div class="flex justify-center w-full">
                <a href="./index.html" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-200">
                    &larr; Back to Main List
                </a>
            </div>

            <div class="flex gap-4 w-full justify-center mt-4">
                <button id="prevPokemonBtn" class="flex items-center p-2 rounded-lg bg-gray-200 text-gray-800 font-semibold shadow-sm hover:bg-gray-300 transition-colors duration-200 text-sm sm:text-base flex-grow sm:flex-grow-0 justify-center" style="display: none;">
                    <span class="text-xl mr-1">&larr;</span>
                    <img id="prevPokemonImg" src="" alt="" class="w-8 h-8 mr-1">
                    <span id="prevPokemonName" class="hidden sm:inline-block capitalize"></span>
                    <span id="prevPokemonId" class="ml-1"></span>
                </button>

                <button id="nextPokemonBtn" class="flex items-center p-2 rounded-lg bg-gray-200 text-gray-800 font-semibold shadow-sm hover:bg-gray-300 transition-colors duration-200 text-sm sm:text-base flex-grow sm:flex-grow-0 justify-center" style="display: none;">
                    <span id="nextPokemonId" class="ml-1"></span>
                    <span id="nextPokemonName" class="hidden sm:inline-block capitalize mr-1"></span>
                    <img id="nextPokemonImg" src="" alt="" class="w-8 h-8 ml-1">
                    <span class="text-xl ml-1">&rarr;</span>
                </button>
            </div>
        </div>

        <div class="main-grid">

            <div class="pokemon-info-card bg-white p-4 sm:p-6 rounded-xl card-custom flex flex-col items-center">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">Basic Info</h2>
                
                <div class="flex flex-col sm:flex-row gap-4 items-center mb-4">
                    <div class="flex flex-col items-center">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Normal</p>
                        <img id="normalPokemonImg" src="" alt="Normal Pokémon" class="w-36 h-36 sm:w-48 sm:h-48 object-contain">
                    </div>
                    <div class="flex flex-col items-center">
                        <p class="text-lg font-semibold text-gray-700 mb-2">Shiny</p>
                        <img id="shinyPokemonImg" src="" alt="Shiny Pokémon" class="w-36 h-36 sm:w-48 sm:h-48 object-contain">
                    </div>
                </div>

                <h3 id="pokemonSubHeader" class="text-xl font-semibold text-gray-700 mb-2 capitalize"></h3>
                <p id="pokemonMeasurements" class="text-gray-600 mb-4 text-sm sm:text-base"></p>
                <div id="pokemonTypes" class="flex flex-wrap justify-center gap-2">
                </div>
            </div>

            <div class="stats-card bg-white p-4 sm:p-6 rounded-xl card-custom flex flex-col">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Stats</h2>
                <div id="pokemonStats">
                </div>

                <h3 class="text-xl font-bold text-gray-800 mt-6 mb-3 text-center">Type Effectiveness</h3>
                <div id="typeEffectivenessContainer">
                </div>
            </div>

            <div class="evolution-tree-card bg-white p-4 sm:p-6 rounded-xl card-custom flex flex-col">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Evolution Tree</h2>
                <div id="evolutionTreeContainer" class="evolution-tree-container">
                </div>
            </div>

            <div class="moves-card bg-white p-4 sm:p-6 rounded-xl card-custom">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Moves</h2>

                <div class="mb-4 flex flex-col sm:flex-row items-center gap-4">
                    <label for="gameVersion" class="font-semibold text-gray-700">Select Version:</label>
                    <select id="gameVersion" class="w-full sm:w-auto p-2 border border-gray-300 rounded-md bg-white text-gray-800 focus:ring-blue-500 focus:border-blue-500">
                    </select>
                </div>

                <div class="move-filter-toggles flex gap-3 mb-4 justify-center">
                    <a id="levelUpFilterBtn" class="filter-btn active" data-filter="level">Level Up</a>
                    <a id="tmhmFilterBtn" class="filter-btn" data-filter="tmhm">TM/HM</a>
                </div>

                <div id="movesTableContainer" class="overflow-x-auto rounded-lg border border-gray-200 shadow-md">
                </div>
            </div>

            <div class="locations-card bg-white p-4 sm:p-6 rounded-xl card-custom">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Locations</h2>
                <div id="locationsContainer">
                </div>
            </div>

        </div>
    </div>

    <script>
        const TypeColor = {
            'normal': { 'bg': '#A8A77A', 'color': 'black' },
            'fire': { 'bg': '#EE8130', 'color': 'black' },
            'water': { 'bg': '#6390F0', 'color': 'white' },
            'electric': { 'bg': '#F7D02C', 'color': 'black' },
            'grass': { 'bg': '#7AC74C', 'color': 'black' },
            'ice': { 'bg': '#96D9D6', 'color': 'black' },
            'fighting': { 'bg': '#C22E28', 'color': 'white' },
            'poison': { 'bg': '#A33EA1', 'color': 'white' },
            'ground': { 'bg': '#E2BF65', 'color': 'black' },
            'flying': { 'bg': '#A98FF3', 'color': 'black' },
            'psychic': { 'bg': '#F95587', 'color': 'white' },
            'bug': { 'bg': '#A6B91A', 'color': 'black' },
            'rock': { 'bg': '#B6A136', 'color': 'black' },
            'ghost': { 'bg': '#735797', 'color': 'white' },
            'dragon': { 'bg': '#6F35FC', 'color': 'white' },
            'dark': { 'bg': '#705746', 'color': 'white' },
            'steel': { 'bg': '#B7B7CE', 'color': 'black' },
            'fairy': { 'bg': '#D685AD', 'color': 'black' },
        };

        const StatsNames = {
            'hp': 'HP',
            'attack': 'Atk',
            'defense': 'Def',
            'special-attack': 'S.Atk',
            'special-defense': 'S.Def',
            'speed': 'Spd',
        };

        const GameVersions = [
            'red-blue', 'yellow', 'gold-silver', 'crystal', 'ruby-sapphire', 'emerald',
            'firered-leafgreen', 'diamond-pearl', 'platinum', 'heartgold-soulsilver',
            'black-white', 'colosseum', 'xd', 'black-2-white-2', 'x-y',
            'omega-ruby-alpha-sapphire', 'sun-moon', 'ultra-sun-ultra-moon',
            'lets-go-pikachu-lets-go-eevee', 'sword-shield',
            'brilliant-diamond-and-shining-pearl', 'scarlet-violet'
        ];

        function formatPokemonNameOrMoves(name) {
            const nameWithSpaces = name.replace(/-/g, ' ');
            return nameWithSpaces.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        }

        const PokedexApp = {
            currentPokemonId: 1,
            selectedVersion: 'red-blue',
            maxPokemonId: 1025,

            async init() {
                const urlParams = new URLSearchParams(window.location.search);
                this.currentPokemonId = parseInt(urlParams.get('id')) || 1;

                const versionInUrl = urlParams.get('version');
                const storedVersion = localStorage.getItem('selectedPokemonGameVersion');

                if (versionInUrl) {
                    this.selectedVersion = versionInUrl;
                    localStorage.setItem('selectedPokemonGameVersion', versionInUrl);
                } else if (storedVersion) {
                    this.selectedVersion = storedVersion;
                    this.navigateToPokemonDetails(this.currentPokemonId, this.selectedVersion, true);
                    return;
                } else {
                    this.selectedVersion = 'red-blue';
                    localStorage.setItem('selectedPokemonGameVersion', this.selectedVersion);
                }

                this.populateVersionDropdown();

                document.getElementById('gameVersion').addEventListener('change', (event) => {
                    this.updateGameVersionAndNavigate(event.target.value);
                });
                document.getElementById('levelUpFilterBtn').addEventListener('click', (event) => {
                    this.toggleMoveFilter(event.target, 'level');
                });
                document.getElementById('tmhmFilterBtn').addEventListener('click', (event) => {
                    this.toggleMoveFilter(event.target, 'tmhm');
                });

                await this.fetchAndRenderPokemonData(this.currentPokemonId, this.selectedVersion);
            },

            async fetchAndRenderPokemonData(pokemonId, version) {
                document.getElementById('pokemonNameHeader').textContent = 'Loading Pokémon...';
                document.body.classList.add('loading');

                try {
                    const pokemonResponse = await fetch(`https://pokeapi.co/api/v2/pokemon/${pokemonId}`);
                    if (!pokemonResponse.ok) throw new Error(`Pokémon ID ${pokemonId} not found.`);
                    const pokemonData = await pokemonResponse.json();

                    const speciesResponse = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${pokemonId}`);
                    if (!speciesResponse.ok) throw new Error(`Species data for ID ${pokemonId} not found.`);
                    const speciesData = await speciesResponse.json();

                    let evolutionChainData = null;
                    if (speciesData.evolution_chain && speciesData.evolution_chain.url) {
                        const evolutionResponse = await fetch(speciesData.evolution_chain.url);
                        if (!evolutionResponse.ok) console.warn("Evolution chain data not found.");
                        evolutionChainData = await evolutionResponse.json();
                    }

                    const encountersResponse = await fetch(`https://pokeapi.co/api/v2/pokemon/${pokemonId}/encounters`);
                    if (!encountersResponse.ok) console.warn("Encounter data not found.");
                    const encountersData = await encountersResponse.json();

                    this.renderPokemonInfo(pokemonData);
                    this.renderStats(pokemonData);
                    this.renderTypeEffectiveness(pokemonData.types);
                    this.renderEvolutionTree(evolutionChainData, pokemonData.name);
                    await this.renderMoves(pokemonData.moves, version);
                    this.renderLocations(encountersData, version);
                    this.updateNavigationButtons(pokemonId);

                } catch (error) {
                    console.error("Failed to fetch Pokémon data:", error);
                    document.getElementById('pokemonNameHeader').textContent = `Error: ${error.message}`;
                    document.getElementById('normalPokemonImg').src = 'https://placehold.co/192x192/cccccc/333333?text=Error';
                    document.getElementById('shinyPokemonImg').src = 'https://placehold.co/192x192/cccccc/333333?text=Error';
                    document.getElementById('pokemonSubHeader').textContent = 'Data Unavailable';
                    document.getElementById('pokemonMeasurements').textContent = '';
                    document.getElementById('pokemonTypes').innerHTML = '';
                    document.getElementById('pokemonStats').innerHTML = '<p class="text-red-500 text-center">Could not load stats.</p>';
                    document.getElementById('typeEffectivenessContainer').innerHTML = '<p class="text-red-500 text-center">Could not load type effectiveness.</p>';
                    document.getElementById('evolutionTreeContainer').innerHTML = '<p class="text-gray-500 text-center">Evolution data not available.</p>';
                    document.getElementById('movesTableContainer').innerHTML = '<p class="text-red-500 text-center">Could not load moves.</p>';
                    document.getElementById('locationsContainer').innerHTML = '<p class="text-red-500 text-center">Could not load locations.</p>';
                } finally {
                    document.body.classList.remove('loading');
                }
            },

            renderPokemonInfo(pokemonData) {
                document.getElementById('pokemonNameHeader').innerHTML = `${formatPokemonNameOrMoves(pokemonData.name)} <span class="text-blue-600">#${pokemonData.id}</span>`;
                document.getElementById('pokemonSubHeader').textContent = formatPokemonNameOrMoves(pokemonData.name);
                document.getElementById('normalPokemonImg').src = pokemonData.sprites.other['official-artwork'].front_default || 'https://placehold.co/192x192/cccccc/333333?text=No+Image';
                document.getElementById('normalPokemonImg').alt = `Normal ${pokemonData.name}`;
                document.getElementById('shinyPokemonImg').src = pokemonData.sprites.other['official-artwork'].front_shiny || 'https://placehold.co/192x192/cccccc/333333?text=No+Shiny';
                document.getElementById('shinyPokemonImg').alt = `Shiny ${pokemonData.name}`;

                const heightMeters = (pokemonData.height * 0.1).toFixed(2);
                const weightKg = (pokemonData.weight * 0.1).toFixed(2);
                document.getElementById('pokemonMeasurements').textContent = `Height: ${heightMeters} m | Weight: ${weightKg} kg`;

                const typesContainer = document.getElementById('pokemonTypes');
                typesContainer.innerHTML = '';
                pokemonData.types.forEach(typeInfo => {
                    const typeName = typeInfo.type.name;
                    const typeStyle = TypeColor[typeName] || { bg: '#6B7280', color: 'white' };
                    const typeSpan = document.createElement('span');
                    typeSpan.className = 'typestyle';
                    typeSpan.style.backgroundColor = typeStyle.bg;
                    typeSpan.style.color = typeStyle.color;
                    typeSpan.textContent = formatPokemonNameOrMoves(typeName);
                    typesContainer.appendChild(typeSpan);
                });
            },

            renderStats(pokemonData) {
                const statsContainer = document.getElementById('pokemonStats');
                statsContainer.innerHTML = '';

                pokemonData.stats.forEach(stat => {
                    const statName = StatsNames[stat.stat.name];
                    const statValue = stat.base_stat;

                    const statDiv = document.createElement('div');
                    statDiv.className = 'stat-container';
                    statDiv.innerHTML = `
                        <span class="stat-name">${statName}:</span>
                        <div class="bar-container">
                            <div class="bar-fill" data-stat-value="${statValue}"></div>
                        </div>
                        <span class="stat-value">${statValue}</span>
                    `;
                    statsContainer.appendChild(statDiv);

                    const barFill = statDiv.querySelector('.bar-fill');
                    const percentage = statValue;
                    barFill.style.width = `${(percentage / 255) * 100}%`;
                    
                    if (statValue <= 60) {
                        barFill.classList.add('red-bar');
                    } else if (statValue <= 100) {
                        barFill.classList.add('yellow-bar');
                    } else {
                        barFill.classList.add('green-bar');
                    }
                });
            },

            async renderTypeEffectiveness(pokemonTypes) {
                const damageMultipliers = {};
                const allTypeNames = Object.keys(TypeColor);

                allTypeNames.forEach(typeName => {
                    damageMultipliers[typeName] = 1;
                });

                for (const pokemonTypeObj of pokemonTypes) {
                    const typeUrl = pokemonTypeObj.type.url;
                    try {
                        const typeResponse = await fetch(typeUrl);
                        if (!typeResponse.ok) throw new Error(`Type data for ${pokemonTypeObj.type.name} not found.`);
                        const typeData = await typeResponse.json();

                        if (typeData && typeData.damage_relations) {
                            const relations = typeData.damage_relations;

                            relations.double_damage_from.forEach(attackingType => {
                                damageMultipliers[attackingType.name] *= 2;
                            });
                            relations.half_damage_from.forEach(attackingType => {
                                damageMultipliers[attackingType.name] *= 0.5;
                            });
                            relations.no_damage_from.forEach(attackingType => {
                                damageMultipliers[attackingType.name] = 0;
                            });
                        }
                    } catch (error) {
                        console.error(`Error fetching type data for ${pokemonTypeObj.type.name}:`, error);
                    }
                }

                const effectiveness = {
                    'immune': [],
                    'resistant': [],
                    'weak': [],
                };

                for (const attackingTypeName in damageMultipliers) {
                    const multiplier = damageMultipliers[attackingTypeName];
                    switch (multiplier) {
                        case 0:
                            effectiveness['immune'].push(attackingTypeName);
                            break;
                        case 0.25:
                            effectiveness['resistant'].push(`${attackingTypeName} (1/4x)`);
                            break;
                        case 0.5:
                            effectiveness['resistant'].push(`${attackingTypeName} (1/2x)`);
                            break;
                        case 2:
                            effectiveness['weak'].push(`${attackingTypeName} (2x)`);
                            break;
                        case 4:
                            effectiveness['weak'].push(`${attackingTypeName} (4x)`);
                            break;
                    }
                }

                effectiveness['immune'].sort();
                effectiveness['resistant'].sort();
                effectiveness['weak'].sort();

                const container = document.getElementById('typeEffectivenessContainer');
                container.innerHTML = '';

                const renderTypeGroup = (title, typesArray) => {
                    if (typesArray.length > 0) {
                        const div = document.createElement('div');
                        div.className = 'mb-3';
                        let html = `<p class="font-semibold text-gray-700 mb-1">${title}:</p><div class="flex flex-wrap gap-2">`;
                        typesArray.forEach(typeInfo => {
                            const typeName = typeInfo.split(' ')[0];
                            const typeStyle = TypeColor[typeName] || { bg: '#6B7280', color: 'white' };
                            html += `
                                <span class="typestyle" style="background-color: ${typeStyle.bg}; color: ${typeStyle.color}">
                                    ${formatPokemonNameOrMoves(typeInfo)}
                                </span>
                            `;
                        });
                        html += `</div>`;
                        div.innerHTML = html;
                        container.appendChild(div);
                    }
                };

                renderTypeGroup('Weaknesses', effectiveness.weak);
                renderTypeGroup('Resistances', effectiveness.resistant);
                renderTypeGroup('Immunities', effectiveness.immune);

                if (effectiveness.weak.length === 0 && effectiveness.resistant.length === 0 && effectiveness.immune.length === 0) {
                    container.innerHTML = '<p class="text-gray-500 text-center">No special type effectiveness.</p>';
                }
            },

            renderEvolutionStage(evolutionNode, currentPokemonName) {
                if (!evolutionNode) return '';

                const pokemonName = evolutionNode.species.name;
                const pokemonId = evolutionNode.species.url.split('/').filter(Boolean).pop();
                const isSelected = (currentPokemonName === pokemonName) ? 'selected' : '';

                let html = `
                    <div class="evolution-pokemon-item">
                        <img src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemonId}.png" 
                            alt="${formatPokemonNameOrMoves(pokemonName)}" 
                            onclick="PokedexApp.navigateToPokemonDetails(${pokemonId})">
                        <p class="${isSelected}">${formatPokemonNameOrMoves(pokemonName)}</p>
                `;

                if (evolutionNode.evolution_details && evolutionNode.evolution_details.length > 0) {
                    html += '<div class="evolution-conditions text-xs text-gray-500 mt-1 flex flex-wrap justify-center gap-x-2">';
                    evolutionNode.evolution_details.forEach(detail => {
                        const conditions = [];
                        if (detail.trigger && detail.trigger.name) {
                            const triggerName = formatPokemonNameOrMoves(detail.trigger.name);
                            if (triggerName === 'Level Up' && detail.min_level > 0) {
                                conditions.push(`Lv. ${detail.min_level}`);
                            } else if (triggerName === 'Trade') {
                                conditions.push('Trade');
                            } else if (triggerName === 'Use Item' && detail.item && detail.item.name) {
                                conditions.push(formatPokemonNameOrMoves(detail.item.name));
                            } else {
                                conditions.push(triggerName);
                            }
                        }

                        if (detail.held_item && detail.held_item.name) {
                            conditions.push(`Hold ${formatPokemonNameOrMoves(detail.held_item.name)}`);
                        }
                        if (detail.gender) {
                            conditions.push(detail.gender == 1 ? 'Female' : 'Male');
                        }
                        if (detail.time_of_day && detail.time_of_day !== '') {
                            conditions.push(detail.time_of_day.charAt(0).toUpperCase() + detail.time_of_day.slice(1));
                        }
                        if (detail.min_happiness > 0) {
                            conditions.push('High Happiness');
                        }
                        if (detail.min_beauty > 0) {
                            conditions.push('High Beauty');
                        }
                        if (detail.min_affection > 0) {
                            conditions.push('High Affection');
                        }
                        if (detail.known_move && detail.known_move.name) {
                            conditions.push(`Know ${formatPokemonNameOrMoves(detail.known_move.name)}`);
                        }
                        if (detail.known_move_type && detail.known_move_type.name) {
                            conditions.push(`Know ${formatPokemonNameOrMoves(detail.known_move_type.name)} Type Move`);
                        }
                        if (detail.location && detail.location.name) {
                            conditions.push(`At ${formatPokemonNameOrMoves(detail.location.name)}`);
                        }
                        if (detail.party_species && detail.party_species.name) {
                            conditions.push(`With ${formatPokemonNameOrMoves(detail.party_species.name)}`);
                        }
                        if (detail.party_type && detail.party_type.name) {
                            conditions.push(`With ${formatPokemonNameOrMoves(detail.party_type.name)} Type`);
                        }
                        if (detail.trade_species && detail.trade_species.name) {
                            conditions.push(`Trade for ${formatPokemonNameOrMoves(detail.trade_species.name)}`);
                        }
                        if (detail.needs_overworld_rain) {
                            conditions.push('Rain');
                        }
                        if (detail.relative_physical_stats !== null) {
                            if (detail.relative_physical_stats === 1) conditions.push('Atk > Def');
                            if (detail.relative_physical_stats === 0) conditions.push('Atk = Def');
                            if (detail.relative_physical_stats === -1) conditions.push('Atk < Def');
                        }
                        if (detail.turn_upside_down) {
                            conditions.push('Upside Down');
                        }

                        if (conditions.length > 0) {
                            html += `<span class="block text-center text-xs text-gray-500">(${conditions.join(', ')})</span>`;
                        }
                    });
                    html += '</div>';
                }
                html += '</div>';

                if (evolutionNode.evolves_to && evolutionNode.evolves_to.length > 0) {
                    html += `
                        <div class="evolution-branch-connector flex justify-center items-center py-2">
                            <span class="evolution-arrow text-3xl text-gray-400">&darr;</span>
                        </div>
                        <div class="evolution-branches flex flex-wrap justify-center gap-4 mt-2">
                    `;
                    evolutionNode.evolves_to.forEach(nextEvolution => {
                        html += `
                            <div class="evolution-branch-item flex flex-col items-center">
                                ${this.renderEvolutionStage(nextEvolution, currentPokemonName)}
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                return html;
            },

            renderEvolutionTree(evolutionChainData, currentPokemonName) {
                const container = document.getElementById('evolutionTreeContainer');
                container.innerHTML = '';

                if (evolutionChainData && evolutionChainData.chain) {
                    container.innerHTML = this.renderEvolutionStage(evolutionChainData.chain, currentPokemonName);
                } else {
                    container.innerHTML = '<p class="text-gray-500">Evolution data not available.</p>';
                }
            },

            populateVersionDropdown() {
                const selectElement = document.getElementById('gameVersion');
                selectElement.innerHTML = '';

                GameVersions.forEach(version => {
                    const option = document.createElement('option');
                    option.value = version;
                    option.textContent = formatPokemonNameOrMoves(version);
                    if (version === this.selectedVersion) {
                        option.selected = true;
                    }
                    selectElement.appendChild(option);
                });
            },

            async renderMoves(allMoves, selectedVersion) {
                const movesForSelectedVersion = [];

                for (const move of allMoves) {
                    const moveName = formatPokemonNameOrMoves(move.move.name);
                    const tempMoveMethods = [];

                    for (const moveVersion of move.version_group_details) {
                        if (moveVersion.version_group.name === selectedVersion) {
                            let level = moveVersion.level_learned_at;
                            let learningMethod = 'level';
                            let displayLevel = level;

                            if (moveVersion.move_learn_method.name === 'machine') {
                                learningMethod = 'tmhm';
                                displayLevel = 'TM/HM';

                                if (moveVersion.machine && moveVersion.machine.url) {
                                    try {
                                        const machineResponse = await fetch(moveVersion.machine.url);
                                        const machineData = await machineResponse.json();
                                        if (machineData && machineData.item && machineData.item.url) {
                                            const itemResponse = await fetch(machineData.item.url);
                                            const itemData = await itemResponse.json();
                                            if (itemData && itemData.name) {
                                                const itemName = itemData.name;
                                                if (itemName.startsWith('tm')) {
                                                    const number = parseInt(itemName.substring(2), 10);
                                                    displayLevel = `TM${String(number).padStart(2, '0')}`;
                                                } else if (itemName.startsWith('hm')) {
                                                    const number = parseInt(itemName.substring(2), 10);
                                                    displayLevel = `HM${String(number).padStart(2, '0')}`;
                                                }
                                            }
                                        }
                                    } catch (error) {
                                        console.warn(`Error fetching machine/item data for move ${moveName}:`, error);
                                    }
                                }
                            } else if (level === 0) {
                                learningMethod = 'tmhm';
                                displayLevel = 'TM/HM';
                            }

                            tempMoveMethods.push({
                                name: moveName,
                                level_learned_at_raw: level,
                                level_learned_at_display: displayLevel,
                                learning_method: learningMethod,
                            });
                        }
                    }
                    movesForSelectedVersion.push(...tempMoveMethods);
                }

                movesForSelectedVersion.sort((a, b) => {
                    const levelComparison = a.level_learned_at_raw - b.level_learned_at_raw;
                    if (levelComparison !== 0) {
                        return levelComparison;
                    }
                    const methodOrder = { 'level': 0, 'tmhm': 1 };
                    const methodComparison = (methodOrder[a.learning_method] || 0) - (methodOrder[b.learning_method] || 0);
                    if (methodComparison !== 0) {
                        return methodComparison;
                    }
                    return a.name.localeCompare(b.name);
                });

                const movesTableContainer = document.getElementById('movesTableContainer');
                movesTableContainer.innerHTML = '';

                if (movesForSelectedVersion.length > 0) {
                    let tableHtml = `
                        <table class="moves-table w-full">
                            <thead>
                                <tr>
                                    <th>Move Name</th>
                                    <th>Learned At</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;
                    movesForSelectedVersion.forEach(moveData => {
                        const initialDisplay = (moveData.learning_method === 'level') ? 'table-row' : 'none';
                        tableHtml += `
                            <tr data-learning-method="${moveData.learning_method}" style="display: ${initialDisplay};">
                                <td>${moveData.name}</td>
                                <td>${moveData.level_learned_at_display}</td>
                            </tr>
                        `;
                    });
                    tableHtml += `
                            </tbody>
                        </table>
                    `;
                    movesTableContainer.innerHTML = tableHtml;

                    const currentActiveFilterBtn = document.querySelector('.move-filter-toggles .filter-btn.active');
                    if (currentActiveFilterBtn) {
                        this.toggleMoveFilter(currentActiveFilterBtn, currentActiveFilterBtn.dataset.filter, false);
                    } else {
                        const levelUpBtn = document.getElementById('levelUpFilterBtn');
                        if (levelUpBtn) {
                            this.toggleMoveFilter(levelUpBtn, 'level');
                        }
                    }

                } else {
                    movesTableContainer.innerHTML = `<p class="text-gray-500 text-center p-4">No moves found for the ${formatPokemonNameOrMoves(selectedVersion)} version.</p>`;
                }
            },

            toggleMoveFilter(clickedButton, filterMethod, updateActiveState = true) {
                if (updateActiveState) {
                    const filterButtons = document.querySelectorAll('.move-filter-toggles .filter-btn');
                    filterButtons.forEach(btn => {
                        btn.classList.remove('active');
                    });
                    clickedButton.classList.add('active');
                }

                const moveRows = document.querySelectorAll('.moves-table tbody tr');
                moveRows.forEach(row => {
                    const learningMethod = row.dataset.learningMethod;
                    if (learningMethod === filterMethod) {
                        row.style.display = 'table-row';
                    } else {
                        row.style.display = 'none';
                    }
                });
            },

            renderLocations(encountersData, selectedVersion) {
                const locationsContainer = document.getElementById('locationsContainer');
                locationsContainer.innerHTML = '';
                const pokemonLocations = [];

                if (encountersData && Array.isArray(encountersData) && encountersData.length > 0) {
                    encountersData.forEach(encounter => {
                        // Verificação defensiva adicionada
                        if (encounter.location_area && encounter.location_area.name) {
                            const locationName = formatPokemonNameOrMoves(encounter.location_area.name);
                            const foundInVersions = new Set();
                            
                            // Verificação defensiva adicionada
                            if (encounter.version_details && Array.isArray(encounter.version_details)) {
                                encounter.version_details.forEach(versionDetail => {
                                    // Verificações defensivas adicionadas para as propriedades aninhadas
                                    if (versionDetail.version_group && versionDetail.version_group.name &&
                                        versionDetail.version && versionDetail.version.name) {
                                        
                                        // Preservando a lógica original do usuário
                                        if (selectedVersion.includes(versionDetail.version_group.name) || versionDetail.version_group.name.includes(selectedVersion)) {
                                            foundInVersions.add(formatPokemonNameOrMoves(versionDetail.version.name));
                                        }
                                    }
                                });
                            }
                            
                            if (foundInVersions.size > 0) {
                                pokemonLocations.push({
                                    location: locationName,
                                    versions: Array.from(foundInVersions).sort()
                                });
                            }
                        }
                    });

                    if (pokemonLocations.length > 0) {
                        pokemonLocations.sort((a, b) => a.location.localeCompare(b.location));
                        let listHtml = '<ul class="location-list">';
                        pokemonLocations.forEach(locationData => {
                            listHtml += `
                                <li class="location-item">
                                    <span>${locationData.location}</span>
                                    <span class="version-tag">
                                        ${locationData.versions.join(', ')}
                                    </span>
                                </li>
                            `;
                        });
                        listHtml += '</ul>';
                        locationsContainer.innerHTML = listHtml;
                    } else {
                        locationsContainer.innerHTML = `<p class="text-gray-500 text-center">Location data not available for the ${formatPokemonNameOrMoves(selectedVersion)} version.</p>`;
                    }
                } else {
                    locationsContainer.innerHTML = `<p class="text-gray-500 text-center">Location data not available.</p>`;
                }
            },

            async updateNavigationButtons(currentId) {
                const prevBtn = document.getElementById('prevPokemonBtn');
                const nextBtn = document.getElementById('nextPokemonBtn');

                const prevId = (currentId > 1) ? currentId - 1 : null;
                const nextId = (currentId < this.maxPokemonId) ? currentId + 1 : null;

                if (prevId !== null) {
                    try {
                        const prevPokemonResponse = await fetch(`https://pokeapi.co/api/v2/pokemon/${prevId}`);
                        if (!prevPokemonResponse.ok) {
                            console.warn(`Could not fetch data for previous Pokémon ID ${prevId}: HTTP Error ${prevPokemonResponse.status}`);
                            prevBtn.style.display = 'none';
                            return;
                        }
                        const prevPokemonData = await prevPokemonResponse.json();
                        if (prevPokemonData && prevPokemonData.name) { 
                            document.getElementById('prevPokemonImg').src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${prevId}.png`;
                            document.getElementById('prevPokemonImg').alt = `Prev ${formatPokemonNameOrMoves(prevPokemonData.name)}`;
                            document.getElementById('prevPokemonName').textContent = formatPokemonNameOrMoves(prevPokemonData.name);
                            document.getElementById('prevPokemonId').textContent = `#${prevId}`;
                            prevBtn.onclick = () => this.navigateToPokemonDetails(prevId);
                            prevBtn.style.display = 'flex';
                        } else {
                            console.warn(`Previous Pokémon ID ${prevId} data is malformed or missing name.`);
                            prevBtn.style.display = 'none';
                        }
                    } catch (error) {
                        console.warn(`Error fetching data for previous Pokémon ID ${prevId}:`, error);
                        prevBtn.style.display = 'none';
                    }
                } else {
                    prevBtn.style.display = 'none';
                }

                if (nextId !== null) {
                    try {
                        const nextPokemonResponse = await fetch(`https://pokeapi.co/api/v2/pokemon/${nextId}`);
                        if (!nextPokemonResponse.ok) {
                            console.warn(`Could not fetch data for next Pokémon ID ${nextId}: HTTP Error ${nextPokemonResponse.status}`);
                            nextBtn.style.display = 'none';
                            return;
                        }
                        const nextPokemonData = await nextPokemonResponse.json();
                        if (nextPokemonData && nextPokemonData.name) { 
                            document.getElementById('nextPokemonImg').src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${nextId}.png`;
                            document.getElementById('nextPokemonImg').alt = `Next ${formatPokemonNameOrMoves(nextPokemonData.name)}`;
                            document.getElementById('nextPokemonName').textContent = formatPokemonNameOrMoves(nextPokemonData.name);
                            document.getElementById('nextPokemonId').textContent = `#${nextId}`;
                            nextBtn.onclick = () => this.navigateToPokemonDetails(nextId);
                            nextBtn.style.display = 'flex';
                        } else {
                            console.warn(`Next Pokémon ID ${nextId} data is malformed or missing name.`);
                            nextBtn.style.display = 'none';
                        }
                    } catch (error) {
                        console.warn(`Error fetching data for next Pokémon ID ${nextId}:`, error);
                        nextBtn.style.display = 'none';
                    }
                } else {
                    nextBtn.style.display = 'none';
                }
            },

            navigateToPokemonDetails(pokemonId, version = this.selectedVersion, replaceState = false) {
                localStorage.setItem('selectedPokemonGameVersion', version);

                const newUrl = `./details.html?id=${pokemonId}&version=${version}`;
                if (replaceState) {
                    window.history.replaceState({}, '', newUrl);
                } else {
                    window.location.href = newUrl;
                }
            },

            updateGameVersionAndNavigate(newVersion) {
                this.selectedVersion = newVersion;
                this.navigateToPokemonDetails(this.currentPokemonId, newVersion);
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            PokedexApp.init();
        });
    </script>

</body>
</html>
